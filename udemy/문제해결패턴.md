# 문제 해결 패턴 소개

## Frequency counter

- Frequency counter는 객체 또는 Set을 사용하여 값의 빈도수 또는 값 자체를 수집하는 패턴이다.
- 이 패턴을 사용하면 종종 중첩 loop를 피할 수 있다.

### Example

Write a function called 'same', which accepts two arrays. The function should return true if every value in the array has it’s corresponding value squared in the second array. The frequency of values must be the same.

```js
// Sample Inputs & Outputs
same([1, 2, 3], [4, 1, 9]); // true
same([1, 2, 3], [1, 9]); // false
same([1, 2, 1], [4, 4, 1]); // false
```

```js
// Solution1 - 중첩 loop(O(N^2))
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    // indexOf 자체가 loop이다.
    let correctIndex = arr2.indexOf(arr1[i] ** 2);
    if (correctIndex === -1) {
      return false;
    }
    arr2.splice(correctIndex, 1);
  }
  return true;
}
```

```js
// Solution2 - Frequency Counter(O(N))
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  let frequencyCounter1 = {};
  let frequencyCounter2 = {};

  // 각 요소의 개수를 value로 갖는 객체를 생성
  for (let val of arr1) {
    frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
  }
  for (let val of arr2) {
    frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
  }

  for (let key in frequencyCounter1) {
    // 첫 번째 객체의 key의 제곱수가 두 번째 객체의 key인지 확인
    if (!(key ** 2 in frequencyCounter2)) {
      return false;
    }
    // 각각의 개수도 맞는지 value를 이용하여 확인
    if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
      return false;
    }
  }
  return true;
}
```

### KeyPoint

두 개의 배열을 객체로 세분화하여 각 배열의 요소들을 분류한 다음, 각 객체를 비교함으로써 코드를 크게 향상시킬 수 있다.

### 도전 과제 - validAnagram

Given two strings, write a function to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cimena, formed from iceman.

```js
// My Solution
function validAnagram(first, second) {
  if (first.length !== second.length) return false;

  const freqCntOfFirst = {};
  const freqCntOfSecond = {};

  for (const val of first) {
    freqCntOfFirst[val] = (freqCntOfFirst[val] || 0) + 1;
  }
  for (const val of second) {
    freqCntOfSecond[val] = (freqCntOfSecond[val] || 0) + 1;
  }

  for (const key in freqCntOfFirst) {
    if (freqCntOfFirst[key] !== freqCntOfSecond[key]) return false;
  }

  return true;
}
```

```js
// Colt Solution
function validAnagram(first, second) {
  if (first.length !== second.length) {
    return false;
  }

  const lookup = {};

  for (let i = 0; i < first.length; i++) {
    let letter = first[i];
    // if letter exists, increment, otherwise set to 1
    lookup[letter] ? (lookup[letter] += 1) : (lookup[letter] = 1);
  }

  for (let i = 0; i < second.length; i++) {
    let letter = second[i];
    // can't find letter or letter is zero then it's not an anagram
    if (!lookup[letter]) {
      return false;
    } else {
      lookup[letter] -= 1;
    }
  }

  return true;
}
```

### KeyPoint

두 대상들의 빈도수를 비교할 때, 각각 객체를 만든 후 비교하는 것도 좋지만, 객체를 하나만 만들고 두 번째 비교군과 비교하며 요소를 빼는 것도 좋다.

---

## Multiple pointers

- index 또는 위치를 나타내는 포인터를 만들고 특정 조건에 따라 포인터를 앞, 중간 또는 뒤로 움직인다.
- 공간 복잡도 측면에서 매우 효율적이다.

**Example**

Write a function called ‘sumZero’ which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist.

```js
// Solution1 - 중첩 loop(O(N^2))
function sumZero(array) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === 0) {
        return [arr[i], arr[j]];
      }
    }
  }
}
```

```js
// Solution2 - Multiple Pointers(O(N))
function sumZero(array) {
  let pointerLeft = 0;
  let pointerRight = array.length - 1;

  while (pointerLeft < pointerRight) {
    // sum을 선언해서 넣어주면 한 번만 계산하면 됨.
    let sum = arr[pointerLeft] + arr[pointerRight];

    if (sum < 0) {
      pointerLeft++;
    } else if (sum > 0) {
      pointerRight--;
    } else {
      return [array[pointerLeft], array[pointerRight]];
    }
  }

  return undefined;
}
```

### 도전과제 - countUniqueValues

Implement a function called ‘countUniqueValues’, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

```js
// My Solution
function countUniqueValues(arr) {
  if (!arr.length) return 0;
  let left = 0;
  let right = 1;
  let count = 1;
  while (right < arr.length) {
    if (arr[left] === arr[right]) {
      right++;
    } else if (arr[left] !== arr[right]) {
      left = right;
      right++;
      count++;
    }
  }
  return count;
}
```

```js
// Colt Solution
function countUniqueValues(arr) {
  var i = 0;
  for (var j = 0; j < arr.length; j++) {
    if (arr[i] !== arr[j]) {
      i++;
      arr[i] = arr[j];
    }
  }
  return i + 1;
}
```

---

## Sliding window

---

## Divide and conquer

---

## Dynamic programming

---

## Greedy algorithms

---

## Back tracking
